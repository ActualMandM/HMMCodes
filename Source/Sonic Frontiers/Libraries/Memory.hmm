Library "Memory" by "Hyper" 
{
    using System.Collections.Generic;

    private static Dictionary<IntPtr, List<byte>> _preservedMemory = new();

    public void Preserve(IntPtr location, long length, bool preserveOnce = true)
    {
        if (location == IntPtr.Zero)
            return;

        if (preserveOnce)
        {
            if (_preservedMemory.ContainsKey(location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(location))
                _preservedMemory.Remove(location);
        }
        
        List<byte> buffer = new();
        for (long i = 0; i < length; i++)
            buffer.Add(Read<byte>(location.ToInt64() + i));

        _preservedMemory.Add(location, buffer);
    }

    public void Preserve(long location, long length, bool preserveOnce = true)
    {
        Preserve(new IntPtr(location), length, preserveOnce);
    }

    public void Restore(IntPtr location)
    {
        if (location == IntPtr.Zero)
            return;

        if (!_preservedMemory.ContainsKey(location))
            return;

        long i = 0;
        foreach (byte b in _preservedMemory[location])
        {
            WriteProtected<byte>(location.ToInt64() + i, b);
            i++;
        }
    }

    public void Restore(long location)
    {
        Restore(new IntPtr(location));
    }

    public long ReadCall(long addr)
    {
        if (addr == 0)
            return 0;

        return addr + Read<int>(addr + 0x01) + 0x05;
    }

    public long ReadEffectiveAddress(long addr)
    {
        if (addr == 0)
            return 0;

        return addr + Read<int>(addr + 0x03) + 0x07;
    }

    public long ReadJump(long addr)
    {
        if (addr == 0)
            return 0;

        sbyte jmpType = -1;
        byte opcode = Read<byte>(addr);

        if ((opcode & 0xF0) == 0x70)
        {
            jmpType = 0;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    jmpType = 0;
                    break;

                case 0xE9:
                    jmpType = 1;
                    break;

                case 0x0F:
                    jmpType = 2;
                    break;

                case 0xFF:
                    jmpType = 3;
                    break;
            }
        }

        switch (jmpType)
        {
            case 0:
                return addr + Read<byte>(addr + 0x01) + 0x02;

            case 1:
                return addr + Read<int>(addr + 0x01) + 0x05;

            case 2:
                return addr + Read<int>(addr + 0x02) + 0x06;

            case 3:
                return Read<long>(addr + 0x06);
        }

        return 0;
    }

    public long ReadThunk(long addr, long offset = 0)
    {
        return ReadJump(ReadCall(addr) + offset);
    }
}


